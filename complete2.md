

## § 5.2. Реализация метода FIFO и распределение себестоимости

В учетных системах метод FIFO является «золотым стандартом» оценки запасов: первыми списываются те партии товаров, которые поступили на склад раньше других. В «1С:Предприятии» это реализуется через упорядочивание записей регистра по временной оси и циклическое распределение остатков.

---

### Граф I. Стратегия извлечения данных и индексация партий

Для реализации партионного учета недостаточно просто знать общее количество товара; необходимо получить детализированный разрез остатков в разрезе документов поступления (партий).

1. **Запрос к виртуальной таблице остатков**:
Использование виртуальной таблицы `.Остатки` с фильтром по массиву номенклатуры позволяет минимизировать объем данных, передаваемых из СУБД в оперативную память.
```bsl
Запрос.Текст = 
    "ВЫБРАТЬ
    |	Себ.Номенклатура КАК Номенклатура,
    |	Себ.Партия КАК Партия,
    |	Себ.КоличествоОстаток КАК Кол,
    |	Себ.СтоимостьОстаток КАК Сумма
    |ИЗ РегистрНакопления.СебестоимостьТоваров.Остатки(&Момент, Номенклатура В (&Массив)) КАК Себ
    |УПОРЯДОЧИТЬ ПО Себ.Партия.МоментВремени ВОЗР";

```


2. **Принцип FIFO в SQL-запросе**:
Ключевым элементом здесь является конструкция `УПОРЯДОЧИТЬ ПО Себ.Партия.МоментВремени ВОЗР`. Сортировка по возрастанию момента времени гарантирует, что при обходе выборки программа сначала «увидит» самые старые поступления.
3. **Кэширование данных (Выгрузить)**:
Выгрузка результата запроса в `ТаблицуЗначений` (`ТабПартий`) — это классический прием для чемпионатов вроде «Волга-ИТ». Это позволяет использовать быстрый метод `.НайтиСтроки()` внутри цикла, избавляя от необходимости выполнять вложенные запросы, что категорически запрещено стандартами производительности 1С.
```bsl
Запрос.УстановитьПараметр("Массив", Материалы.ВыгрузитьКолонку("Номенклатура"));
ТабПартий = Запрос.Выполнить().Выгрузить();
	СуммаМат = 0; // Накопитель общей стоимости материалов
	Для Каждого Стр Из Материалы Цикл
		Надо = Стр.Количество;
		// Ищем все партии для конкретной номенклатуры из строки
		Найденные = ТабПартий.НайтиСтроки(Новый Структура("Номенклатура", Стр.Номенклатура));
		
		Для Каждого Парт Из Найденные Цикл
			Если Надо <= 0 Тогда Прервать; КонецЕсли; // Если всё количество списали — выходим
			Если Парт.Кол <= 0 Тогда Продолжить; КонецЕсли; // Если в партии пусто — к следующей


```



---

### Граф II. Алгоритм пропорционального списания и синхронизация регистров

Этот блок описывает логику «пожирания» партий: как одна строка документа может распределиться по нескольким записям регистра.

1. **Расчет фактического списания**:
Функция `Мин(Надо, Парт.Кол)` — это ядро алгоритма. Она определяет, сколько ресурсов мы можем забрать из конкретной партии, не уходя «в минус».
```bsl
Факт = Мин(Надо, Парт.Кол);

```


2. **Математика себестоимости**:
При частичном списании партии стоимость рассчитывается пропорционально количеству.
> **Теоретическая формула:**
> 
> 
> 
> Важно: при списании партии «в ноль» (целиком), необходимо забирать всю копеечную сумму остатка без деления, чтобы избежать «зависания» копеек из-за погрешностей округления.


```bsl
Если Факт = Парт.Кол Тогда
    СуммаСпис = Парт.Сумма;
Иначе
    СуммаСпис = (Парт.Сумма / Парт.Кол) * Факт;
КонецЕсли;

```


3. **Синхронное формирование движений**:
В 1С важно соблюдать корреляцию между регистрами. Если мы уменьшаем финансовую стоимость (`СебестоимостьТоваров`), мы обязаны синхронно уменьшить количественный остаток на складе (`ОстаткиТоваров`).
```bsl
ДвS.ВидДвижения = ВидДвиженияНакопления.Расход;
// ... заполнение реквизитов
ДвO.ВидДвижения = ВидДвиженияНакопления.Расход;

```


4. **Актуализация состояния памяти**:
Поскольку один документ может содержать одинаковую номенклатуру в разных строках, после каждого «списания» необходимо обновлять данные в `ТабПартий`. Это гарантирует, что следующая строка документа увидит актуальный остаток партии, уменьшенный предыдущими строками.
```bsl
// Уменьшаем счетчики для следующего итерационного шага
Надо = Надо - Факт;
Парт.Кол = Парт.Кол - Факт;
Парт.Сумма = Парт.Сумма - СуммаСпис;
СуммаМат = СуммаМат + СуммаСпис;
```


