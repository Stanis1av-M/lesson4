

## § 5. Проведение документа: Контроль и Списание

Процедура `ОбработкаПроведения` — это серверный обработчик, который отвечает за проверку корректности данных перед записью в регистры накопления.

### 1. Подготовка и сворачивание данных

Перед началом проверок табличная часть выгружается в **Таблицу Значений** и сворачивается (`TЗ_Товары.Свернуть`). Это критически важно: если пользователь ввел одну и ту же номенклатуру в две разные строки, система должна проверять общий остаток по товару, а не каждую строку по отдельности.

### 2. БЛОК 1: Контроль остатков (Оперативный учет)

Цель этого блока — не допустить «ухода в минус» на складе.

* **Использование запроса**: Остатки извлекаются из виртуальной таблицы `Остатки` регистра `ОстаткиТоваров`.
* **Индексация**: Для ускорения поиска в цикле к таблице результатов запроса добавляется индекс по колонке `Номенклатура`.
* **Отказ от проведения**: Если требуемое количество (`Надо`) превышает имеющееся (`Есть`), переменная `Отказ` устанавливается в `Истина`. Это прерывает транзакцию, и документ остается не проведенным.

---

### 3. БЛОК 2: Партионный учет по методу FIFO

Метод **FIFO** (First In, First Out) подразумевает, что первым списывается товар, который поступил на склад раньше всех.

#### А) Извлечение партий

Запрос обращается к регистру `СебестоимостьТоваров`. Ключевая особенность здесь — сортировка:

```bsl
УПОРОДЯДОЧИТЬ ПО Себ.Партия.МоментВремени ВОЗР

```

Это гарантирует, что в таблицу результатов первыми попадут самые старые партии.

#### Б) Алгоритм распределения (Цикл в цикле)

Для каждой строки товара запускается внутренний цикл по найденным партиям:

* **Мин(ОсталосьСписать, Парт.Кол)**: Определяется фактическое количество, которое можно забрать из текущей партии.
* **Расчет стоимости**: Используется формула средней цены партии.
> **Важный нюанс**: При списании партии «в ноль» программа забирает весь остаток суммы (`Парт.Сумма`), чтобы избежать накопления «копеек» из-за погрешностей деления.


* **Обновление локальных данных**: После формирования движения данные в переменной `Парт` (строка таблицы партий) уменьшаются. Это необходимо, если одна и та же номенклатура встречается в документе несколько раз.

---

### Ключевые механизмы 1С, использованные в коде:

1. **МоментВремени()**: Обеспечивает получение остатков строго на секунду документа, включая его самого (в режиме проведения).
2. **ВидДвиженияНакопления.Расход**: Указывает регистрам, что ресурсы (товар и деньги) выбывают из системы.
3. **Движения.ИмяРегистра.Записывать = Истина**: Флаг, разрешающий системе физически записать сформированные строки в базу данных по завершении процедуры.

---

	Процедура ОбработкаПроведения(Отказ, Режим)
	
	// Подготавливаем данные: сворачиваем дубли номенклатуры в табличной части
	TЗ_Товары = Товары.Выгрузить();
	TЗ_Товары.Свернуть("Номенклатура", "Количество");
	
	// --- БЛОК 1: Контроль остатков на складе ---
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	Ост.Номенклатура КАК Номенклатура,
		|	ISNULL(Ост.КоличествоОстаток, 0) КАК ВНаличии
		|ИЗ
		|	РегистрНакопления.ОстаткиТоваров.Остатки(&Момент, 
		|		Склад = &Склад И Номенклатура В (&СписокТоваров)) КАК Ост";
	
	// Устанавливаем параметры для проверки остатков
	Запрос.УстановитьПараметр("Момент", МоментВремени());
	Запрос.УстановитьПараметр("Склад", Склад);
	Запрос.УстановитьПараметр("СписокТоваров", TЗ_Товары.ВыгрузитьКолонку("Номенклатура"));
	
	// Выгружаем остатки и создаем индекс для быстрого поиска в цикле
	ТаблицаОстатков = Запрос.Выполнить().Выгрузить();
	ТаблицаОстатков.Индексы.Добавить("Номенклатура");
	
	// Проверяем наличие каждого товара
	Для Каждого Стр ИЗ TЗ_Товары Цикл
		Надо = Стр.Количество;
		Есть = 0;
		// Ищем строку с остатком для текущего товара
		Найденные = ТаблицаОстатков.НайтиСтроки(Новый Структура("Номенклатура", Стр.Номенклатура));
		Если Найденные.Количество() > 0 Тогда
			Есть = Найденные[0].ВНаличии;
		КонецЕсли;
		
		// Если товара на складе меньше, чем в документе — выводим ошибку
		Если Надо > Есть Тогда
			Сообщение = Новый СообщениеПользователю;
			Сообщение.Текст = "Не хватает: " + Стр.Номенклатура + ". Надо: " + Надо + ", Есть: " + Есть;
			Сообщение.Сообщить();
			Отказ = Истина; // Запрещаем проведение документа
		КонецЕсли;
	КонецЦикла;
	
	// Если проверка не прошла, прерываем процедуру проведения
	Если Отказ Тогда Возврат; КонецЕсли;

	// Разрешаем запись движений в регистры
	Движения.ОстаткиТоваров.Записывать = Истина;
	Движения.СебестоимостьТоваров.Записывать = Истина;
	
	// --- БЛОК 2: Получение партий для списания себестоимости (FIFO) ---
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	Себ.Номенклатура,
		|	Себ.Партия,
		|	Себ.КоличествоОстаток КАК Кол,
		|	Себ.СтоимостьОстаток КАК Сумма
		|ИЗ
		|	РегистрНакопления.СебестоимостьТоваров.Остатки(&Момент, 
		|		Номенклатура В (&СписокТоваров)) КАК Себ
		|УПОРЯДОЧИТЬ ПО
		|	Себ.Партия.МоментВремени ВОЗР"; // Сортировка по времени поступления
	
	ТабПартий = Запрос.Выполнить().Выгрузить();
	ТабПартий.Индексы.Добавить("Номенклатура"); // Индексируем для ускорения
	
	// Основной цикл формирования движений
	Для Каждого Стр Из Товары Цикл 
		
		// 1. Формируем движение расхода по остаткам (количественный учет)
		ДвО = Движения.ОстаткиТоваров.Добавить();
		ДвО.ВидДвижения = ВидДвиженияНакопления.Расход;
		ДвО.Период = Дата;
		ДвО.Склад = Склад;
		ДвО.Номенклатура = Стр.Номенклатура;
		ДвО.Количество = Стр.Количество;
		
		// 2. Списание себестоимости по партиям
		ОсталосьСписать = Стр.Количество;
		Найденные = ТабПартий.НайтиСтроки(Новый Структура("Номенклатура", Стр.Номенклатура));
		
		Для Каждого Парт Из Найденные Цикл
			Если ОсталосьСписать <= 0 Тогда Прервать; КонецЕсли;
			Если Парт.Кол <= 0 Тогда Продолжить; КонецЕсли;
			
			// Рассчитываем, сколько забираем из этой партии
			Факт = Мин(ОсталосьСписать, Парт.Кол);
			
			// Рассчитываем стоимость (если партия списывается в ноль — берем остаток суммы, чтобы не было копеек)
			СуммаСпис = ?(Факт = Парт.Кол, Парт.Сумма, (Парт.Сумма / Парт.Кол) * Факт);
			
			// Формируем движение по регистру себестоимости
			ДвС = Движения.СебестоимостьТоваров.Добавить();
			ДвС.ВидДвижения = ВидДвиженияНакопления.Расход;
			ДвС.Период = Дата;
			ДвС.Номенклатура = Стр.Номенклатура;
			ДвС.Партия = Парт.Партия;
			ДвС.Количество = Факт;
			ДвС.Стоимость = СуммаСпис;
			
			// Уменьшаем остаток, который еще нужно распределить по следующим партиям
			ОсталосьСписать = ОсталосьСписать - Факт;
			// Обновляем данные в локальной таблице партий
			Парт.Кол = Парт.Кол - Факт;
			Парт.Сумма = Парт.Сумма - СуммаСпис;
		КонецЦикла;
		
	КонецЦикла;

	КонецПроцедуры
	Напиши конспект также
